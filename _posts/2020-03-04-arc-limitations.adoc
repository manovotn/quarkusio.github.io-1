---
layout: post
date:   2020-03-04 00:00 +0100
author: mkouba
synopsis: ArC limitations explained.
---

== Quarkus ArC and CDI Limitations 

In the previous blogpost about https://quarkus.io/blog/quarkus-dependency-injection/[Quarkus Dependency Injection] we explained the relationship to the CDI specification.
We also mentioned some of the benefits and drawbacks of the build-time oriented design.

In this article, we're going to describe the https://quarkus.io/guides/cdi-reference#limitations[notable limitations] and explain the reasonings behind our decisions to leave out those features and add some https://quarkus.io/guides/cdi-reference#non-standard-features[non-standard features] instead.

[NOTE]
====
Red Hat has been involved in CDI for many years. 
It's been responsible for leading the http://cdi-spec.org/[specification], implementing and maintaining the https://github.com/eclipse-ee4j/cdi-tck[TCK] and the http://weld.cdi-spec.org/[reference implementation].
====

=== On The Way To CDI Lite

Our primary goal was to provide a DI solution that would be aligned with the Quarkus mindset:

* Based on well known standard,
* Build-time oriented,
* Fast and lightweight.

Speaking of standards, the choice was clear: CDI - a technology we have extensive experience with at all levels.
But we soon realized that the current reference implementation (Weld) won't do -  we needed a lighter alternative.

First, we tried to identify the _dispensable features_ (`D`) that:

* Are rarely used,
* Cause troubles to users and/or implementors,
* Do not fit well into the build-time oriented scheme,
* Make the implementation overly complex, ie. less maintainable and harder to understand.

Afterwards, we compiled a list of _must-have features_ (`M`), such as:

* Type-safe resolution,
* Observers, interceptors
* Alternatives,
* Proxies and much more...

[NOTE]
====
It is noteworthy that the set was built from users point of view.
For the integration part, Quarkus extension framework should be leveraged.
====

Then we identified the resulting set of features `F` as `F = C \ (D \ M)` where `C` is a set of all CDI features.
Finally, we implemented `F` and the result runs under the hood of every Quarkus application!

Let's go through some of the "dispensable" features that ended in the set of limitations.

=== Conversation Context

The concept of conversations is simple - a scope that can span across multiple requests but does not outlive a session.
In CDI 1.0, a conversation scope was a "trimmed version" of https://docs.jboss.org/seam/2.3.1.Final/reference/html/tutorial.html#d0e1951[Seam conversations] grafted on the CDI API.
Therefore, it was tied to the https://javaee.github.io/javaserverfaces-spec/[JSF technology].
However, the specification version was not so powerful and with the decline in the popularity of stateful web frameworks, its importance significantly dropped over time.
Since CDI 1.1, the conversation context is available in any Servlet request and conversations may be propagated via request parameter.

Reasons to skip:

* Requires Servlets - Quarkus web is built on top of Vert.x and Servlets are optional.
* Tied to HTTP session which:
** Is considered a bad practice in the microservices world,
** Requires synchronization and locking.
* There are quite some corner cases and gray areas which make it really tricky to implement the specification correctly. To name a few:
** Conversation lifecycle is not fully aligned with the lifecycle of HTTP Session, ie. when a HTTP session is invalidated within a request.
** In JSF a long-running conversation is https://issues.redhat.com/browse/WELD-2081[not propagated if started through an AJAX Faces request]. 
** The container provides a `Conversation` built-in bean named `javax.enterprise.context.conversation`.
But according to https://issues.redhat.com/browse/CDI-498[some experts] this name is not a valid EL identifier.
** Transient conversations are https://issues.redhat.com/browse/WELD-1520[not propagated across Servlet dispatch].
 
NOTE: In Weld, we keep records of https://issues.redhat.com/issues/?jql=project%20%3D%20WELD%20and%20type%20%3D%20bug%20AND%20(component%20%3D%20Conversations%20or%20summary%20~%20%22conversation%22)%20ORDER%20BY%20key%20DESC[65 bugs] (90 issues in total) related to conversations.

=== Decorators

Decorators are less known companions of interceptors.
While interceptors are used to implement the cross-cutting concerns, ie. to solve some technical problems like logging or security, decorators intercept invocations of a specific Java interface and so they often implement some business logic.

Reasons to skip:

* Low adoption.
* Complex and hard to understand due to specific set of https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#decorator_resolution[resolution rules].
* Technical demands, especially when used together with interceptors.

NOTE: In Weld, we keep records of https://issues.redhat.com/issues/?jql=project%20%3D%20WELD%20and%20type%20%3D%20bug%20AND%20(component%20%3D%20Decorators%20%20or%20summary%20~%20%22decorator%22)%20ORDER%20BY%20key%20DESC[67 bugs] (93 issues in total) related to decorators.

=== Portable Extensions

Portable extensions represent a powerful integration tool.
On the other hand, the API is quite complex the implementation must provide non-trivial abstraction layers (such as `AnnotatedType`).
  
Reasons to skip:

* Noticable performance overhead,
* Portable extensions are inherently _runtime components_ that are very often stateful.

IMPORTANT: It would never be possible to run all existing portable extensions in the build phase!

=== Specialization

Specialization is similar to alternatives and the two are sometimes a source of confusion.
The main difference is that a specialized/overriden bean is never instantiated or called by the container, even if it defines a producer or observer method.
Unfortunately, the definition is not that simple and caused ambiguities among CDI implementors, especially in modular environments.

Reasons to skip:

* Low adoption, caused by problematic definition and portability issues,
* Very few use cases actually require specialization, most can be solved with proper use of Alternatives.

NOTE: In Weld, we keep records of https://issues.redhat.com/issues/?jql=project%20%3D%20weld%20and%20type%20%3D%20bug%20AND%20summary%20~%20%22specialize%22%20ORDER%20BY%20key%20DESC[23 bugs] (28 issues in total and 6 open specification issues) related to specialization.

=== Explicit Bean Archives

https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_archive[Explicit Bean Archive] is an old-style CDI 1.0 way of packaging beans.
The main disadvantages are noticeable bootstrap performance overhead and increased memory consumption.
For an explicit bean archive the container needs to analyze _every class_ and those that meet https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#what_classes_are_beans[certain conditions] are considered beans.  
This is very often suboptimal.

We've seen many deployments where hundreds of classes were recognized as beans but never used at runtime and the related metadata was hold in memory for the lifetime of the application.
Also each class results in many container lifecycle events (`ProcessAnnotatedType`, `ProcessManagedBean`, etc.) consumed by portable extensions during bootstrap.  

The CDI Expert Group attempted to solve this problem with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[new discovery mode] (which is the default since 1.1) and https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#trimmed_bean_archive[trimmed bean archives]. 
Weld contains a lot of optimizations to speed-up the bootstrap process.
TODO However, these optimizations make the code complicated and some of them .

Reasons to drop support:

* Noticeable bootstrap performance overhead.
* Increased memory usage in order to store the metadata,
* Defeats the goal of minimal footprint of user application.

=== Passivation and Passivating Scopes

Passivation is mostly related to HTTP sessions.
In theory, any normal scope may be a passivating scope.
But in reality, the only passivating scopes used in the wild are `@SessionScoped` and `@ConversationScoped`. 

Reasons to drop support:

* Quarkus only supports in-memory HTTP sessions
* `@SessionScoped` is considered a bad practice in the microservices world
* Passivation requires quite a lot of non-trivial yet ubiquitous code modifications, e.g. to handle passivation capable dependencies correctly

NOTE: In Weld, we keep records of https://issues.redhat.com/issues/?jql=project%20%3D%20weld%20and%20type%20%3D%20bug%20AND%20summary%20~%20%22passivation%22%20ORDER%20BY%20key%20DESC[17 bugs] related to passivation.

== Conclusion

In order to make our DI built-time friendly and supersonic, we made some tough decisions to leave out some of the features required by the CDI specification.
The result is a more lightweight but still very powerful and convenient component model.
In the next article, we're going to describe the https://quarkus.io/guides/cdi-reference#non-standard-features[non-standard features] that can make the life of Quarkus users so much easier.
